{"version":3,"sources":["components/Button/index.js","components/LivesRemaining/index.js","components/HiddenWord/index.js","components/LetterPicker/index.js","Game.js","serviceWorker.js","index.js"],"names":["Button","children","className","props","clsx","LivesRemaining","lives","HiddenWord","currentWord","knownLetters","map","letter","ind","includes","LetterPicker","choices","onClick","alphabet","getRandomItem","items","Math","floor","random","length","Game","useState","setKnownLetters","setCurrentWord","setChoices","livesRemaining","setLivesRemaining","notify","setNotify","resetGame","pickWord","generateChoices","nextKnownLetters","unknownLetters","filter","correctChoice","badLetters","badChoices","shuffle","splice","useEffect","word","words","split","identifiedWord","uniq","showLetterPicker","data-testid","push","setTimeout","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.1f2e9dc4.chunk.js","sourcesContent":["import React from \"react\"\nimport clsx from \"clsx\"\n\nimport \"./Button.css\"\n\nconst Button = ({ children, className, ...props }) => {\n  return (\n    <button className={clsx(\"button\", className)} {...props}>\n      {children}\n    </button>\n  )\n}\n\nexport default Button\n","import React from \"react\"\nimport \"./LivesRemaining.css\"\n\nconst LivesRemaining = ({ lives }) => (\n  <div className=\"live-remaining\">\n    <span className=\"lives-remaining__num\">{lives}</span>\n    <span className=\"lives-remaining__text\">lives</span>\n  </div>\n)\n\nexport default LivesRemaining\n","import React from \"react\"\n\nimport \"./HiddenWord.css\"\n\nconst HiddenWord = ({ currentWord, knownLetters }) => {\n  return (\n    <div className=\"hidden-word\">\n      {currentWord.map((letter, ind) => (\n        <>\n          {knownLetters.includes(letter) ? (\n            <span className=\"hidden-letter hidden-letter--known\">{letter}</span>\n          ) : (\n            <span className=\"hidden-letter hidden-letter--unknown\"></span>\n          )}\n        </>\n      ))}\n    </div>\n  )\n}\n\nexport default HiddenWord\n","import React from \"react\"\nimport \"./LetterPicker.css\"\nimport Button from \"../Button\"\n\nconst LetterPicker = ({ choices, onClick }) => (\n  <div className=\"letter-picker-wrap\">\n    <h2>Pick a letter</h2>\n    <div className=\"letter-picker\">\n      {choices.map((letter, ind) => (\n        <Button\n          className=\"button--letter-picker\"\n          onClick={() => onClick(letter)}\n        >\n          <span>{letter}</span>\n        </Button>\n      ))}\n    </div>\n  </div>\n)\n\nexport default LetterPicker\n","import React, { useState, useEffect } from \"react\"\n\nimport uniq from \"lodash.uniq\"\nimport shuffle from \"lodash.shuffle\"\n\nimport \"./Game.css\"\nimport Button from \"./components/Button\"\nimport LivesRemaining from \"./components/LivesRemaining\"\nimport HiddenWord from \"./components/HiddenWord\"\nimport LetterPicker from \"./components/LetterPicker\"\n\nimport words from \"./words.json\"\n\nconst alphabet = [\n  \"a\",\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n  \"j\",\n  \"k\",\n  \"l\",\n  \"m\",\n  \"n\",\n  \"o\",\n  \"p\",\n  \"q\",\n  \"r\",\n  \"s\",\n  \"t\",\n  \"u\",\n  \"v\",\n  \"x\",\n  \"y\",\n  \"z\",\n]\n\nconst defaultLives = 10\nconst minWordLength = 4\nconst maxWordLength = 8\n\nconst getRandomItem = (items) => items[Math.floor(Math.random() * items.length)]\n\nfunction Game() {\n  const [knownLetters, setKnownLetters] = useState([])\n  const [currentWord, setCurrentWord] = useState([])\n  const [choices, setChoices] = useState([])\n  const [livesRemaining, setLivesRemaining] = useState(defaultLives)\n  const [notify, setNotify] = useState(false)\n\n  const resetGame = () => {\n    setCurrentWord(pickWord())\n    setLivesRemaining(defaultLives)\n    setChoices(generateChoices())\n    setKnownLetters([])\n  }\n\n  const generateChoices = (nextKnownLetters = []) => {\n    if (!currentWord.length) return nextKnownLetters\n\n    const unknownLetters = currentWord.filter(\n      (letter) => !nextKnownLetters.includes(letter)\n    )\n    const correctChoice = getRandomItem(unknownLetters)\n\n    const badLetters = alphabet.filter(\n      (letter) => !currentWord.includes(letter)\n    )\n    const badChoices = shuffle(badLetters).splice(0, 5)\n\n    return shuffle([correctChoice, ...badChoices])\n  }\n\n  useEffect(() => {\n    if (!currentWord.length) {\n      resetGame()\n    }\n\n    if (!choices.length) {\n      // console.log(currentWord)\n      setChoices(generateChoices())\n    }\n  }, [currentWord, choices, resetGame, setChoices, generateChoices])\n\n  const pickWord = () => {\n    let word = getRandomItem(words)\n\n    while (word.length > maxWordLength || word.length < minWordLength) {\n      word = getRandomItem(words)\n    }\n\n    return word.split(\"\")\n  }\n\n  const checkLetter = (letter) => {\n    const nextKnownLetters = knownLetters\n\n    if (currentWord.includes(letter)) {\n      setNotify(\"correct\")\n      nextKnownLetters.push(letter)\n    } else {\n      setNotify(\"incorrect\")\n      setLivesRemaining(livesRemaining - 1)\n    }\n\n    setKnownLetters(nextKnownLetters)\n    setChoices(generateChoices(nextKnownLetters))\n\n    setTimeout(() => setNotify(false), 1000)\n  }\n\n  const identifiedWord = knownLetters.length === uniq(currentWord).length\n  const showLetterPicker = !notify && !identifiedWord && livesRemaining\n\n  return (\n    <div className=\"Game\">\n      <header className=\"Game-header\">\n        <LivesRemaining lives={livesRemaining} />\n        <Button onClick={resetGame}>New Word</Button>\n      </header>\n\n      <h1 data-testid=\"title\">Can you guess the word?</h1>\n\n      <HiddenWord knownLetters={knownLetters} currentWord={currentWord} />\n\n      {!!showLetterPicker && (\n        <LetterPicker choices={choices} onClick={checkLetter} />\n      )}\n\n      {notify === \"incorrect\" && !!livesRemaining && (\n        <p>\n          Whoops! <br /> {livesRemaining} lives remaining\n        </p>\n      )}\n\n      {!identifiedWord && notify === \"correct\" && (\n        <p>\n          Awesome, you got\n          <br /> a letter!\n        </p>\n      )}\n\n      {identifiedWord && (\n        <>\n          <p>\n            You guessed the word, <br /> Congratulations!\n          </p>\n          <Button onClick={resetGame}>Play Again?</Button>\n        </>\n      )}\n\n      {!livesRemaining && (\n        <>\n          <p>\n            You have no lives left, <br /> better luck next time\n          </p>\n          <Button onClick={resetGame}>Play Again?</Button>\n        </>\n      )}\n    </div>\n  )\n}\n\nexport default Game\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n)\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\")\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error)\n    })\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\")\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      )\n    })\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister()\n      })\n      .catch((error) => {\n        console.error(error.message)\n      })\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Game from './Game';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Game />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}